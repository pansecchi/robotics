{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red12\green12\blue12;\red255\green255\blue255;
\red39\green129\blue201;\red20\green152\blue106;\red212\green20\blue102;\red235\green16\blue47;\red255\green255\blue255;
\red226\green131\blue14;}
{\*\expandedcolortbl;;\cssrgb\c100000\c100000\c100000;\cssrgb\c5098\c5098\c5098;\cssrgb\c100000\c100000\c100000\c60000;
\cssrgb\c18039\c58431\c82745;\cssrgb\c0\c65098\c49020;\cssrgb\c87451\c18824\c47451;\cssrgb\c94902\c17255\c23922;\cssrgb\c100000\c100000\c100000\c50196;
\cssrgb\c91373\c58431\c4706;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 #\strokec5 include\strokec4  \strokec6 "ros/ros.h"\cf2 \strokec2 \
\cf2 \strokec4 #\strokec5 include\strokec4  \strokec6 "nav_msgs/Odometry.h"\cf2 \strokec2 \
\cf2 \strokec4 #\strokec5 include\strokec4  \strokec6 "geometry_msgs/Point.h"\cf2 \strokec2 \
\cf2 \strokec4 #\strokec5 include\strokec4  \strokec6 "geometry_msgs/Quaternion.h"\cf2 \strokec2 \
\cf2 \strokec4 #\strokec5 include\strokec4  \strokec6 <cmath>\cf2 \strokec2 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec7 double\cf2 \strokec2  \cf2 \strokec8 calculateDirection\cf2 \strokec2 (\cf2 \strokec7 double\cf2 \strokec2  x1, \cf2 \strokec7 double\cf2 \strokec2  y1, \cf2 \strokec7 double\cf2 \strokec2  x2, \cf2 \strokec7 double\cf2 \strokec2  y2) \{\
    \cf2 \strokec9 // Calcola l'angolo in radianti tra due punti (x1, y1) e (x2, y2)\cf2 \strokec2 \
    \cf2 \strokec5 return\cf2 \strokec2  \cf2 \strokec10 atan2\cf2 \strokec2 (y2 - y1, x2 - x1);\
\}\
\
\cf2 \strokec7 int\cf2 \strokec2  \cf2 \strokec8 main\cf2 \strokec2 (\cf2 \strokec7 int\cf2 \strokec2  argc, \cf2 \strokec7 char\cf2 \strokec2  **argv) \{\
    ros::\cf2 \strokec10 init\cf2 \strokec2 (argc, argv, \cf2 \strokec6 "gps_odom_publisher"\cf2 \strokec2 );\
    ros::NodeHandle nh;\
\
    ros::Publisher odom_pub = nh.\cf2 \strokec10 advertise\cf2 \strokec2 <nav_msgs::Odometry>(\cf2 \strokec6 "gps_odom"\cf2 \strokec2 , \cf2 \strokec7 10\cf2 \strokec2 );\
\
    ros::Rate \cf2 \strokec8 loop_rate\cf2 \strokec2 (\cf2 \strokec7 10\cf2 \strokec2 );  \cf2 \strokec9 // 10 Hz\cf2 \strokec2 \
\
    \cf2 \strokec7 double\cf2 \strokec2  prev_e = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
    \cf2 \strokec7 double\cf2 \strokec2  prev_n = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
\
    \cf2 \strokec5 while\cf2 \strokec2  (ros::\cf2 \strokec10 ok\cf2 \strokec2 ()) \{\
        \cf2 \strokec9 // Replace these values with your ENU coordinates\cf2 \strokec2 \
        \cf2 \strokec7 double\cf2 \strokec2  e = \cf2 \strokec7 10.0\cf2 \strokec2 ;\
        \cf2 \strokec7 double\cf2 \strokec2  n = \cf2 \strokec7 5.0\cf2 \strokec2 ;\
        \cf2 \strokec7 double\cf2 \strokec2  u = \cf2 \strokec7 0.0\cf2 \strokec2 ;  \cf2 \strokec9 // Assuming flat terrain\cf2 \strokec2 \
\
        \cf2 \strokec9 // Calculate direction (angle) between previous and current position\cf2 \strokec2 \
        \cf2 \strokec7 double\cf2 \strokec2  direction = \cf2 \strokec10 calculateDirection\cf2 \strokec2 (prev_e, prev_n, e, n);\
\
        nav_msgs::Odometry odom;\
        odom.header.stamp = ros::Time::\cf2 \strokec10 now\cf2 \strokec2 ();\
        odom.header.frame_id = \cf2 \strokec6 "odom"\cf2 \strokec2 ;\
        odom.child_frame_id = \cf2 \strokec6 "base_link"\cf2 \strokec2 ;\
\
        \cf2 \strokec9 // Position\cf2 \strokec2 \
        odom.pose.pose.position.x = e;\
        odom.pose.pose.position.y = n;\
        odom.pose.pose.position.z = u;\
\
        \cf2 \strokec9 // Orientation (quaternion)\cf2 \strokec2 \
        \cf2 \strokec7 double\cf2 \strokec2  theta = direction;  \cf2 \strokec9 // Angle in radians\cf2 \strokec2 \
        odom.pose.pose.orientation.x = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.pose.pose.orientation.y = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.pose.pose.orientation.z = \cf2 \strokec10 sin\cf2 \strokec2 (theta / \cf2 \strokec7 2\cf2 \strokec2 );\
        odom.pose.pose.orientation.w = \cf2 \strokec10 cos\cf2 \strokec2 (theta / \cf2 \strokec7 2\cf2 \strokec2 );\
\
        \cf2 \strokec9 // Twist (not necessary for your case, but included for completeness)\cf2 \strokec2 \
        odom.twist.twist.linear.x = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.linear.y = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.linear.z = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.angular.x = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.angular.y = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.angular.z = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
\
        \cf2 \strokec9 // Publish the message\cf2 \strokec2 \
        odom_pub.\cf2 \strokec10 publish\cf2 \strokec2 (odom);\
\
        \cf2 \strokec9 // Update previous position\cf2 \strokec2 \
        prev_e = e;\
        prev_n = n;\
\
        ros::\cf2 \strokec10 spinOnce\cf2 \strokec2 ();\
        loop_rate.\cf2 \strokec10 sleep\cf2 \strokec2 ();\
    \}\
\
    \cf2 \strokec5 return\cf2 \strokec2  \cf2 \strokec7 0\cf2 \strokec2 ;\
\}\cf2 \strokec4 #\strokec5 include\strokec4  \strokec6 "ros/ros.h"\cf2 \strokec2 \
\pard\pardeftab720\partightenfactor0
\cf2 \strokec4 #\strokec5 include\strokec4  \strokec6 "nav_msgs/Odometry.h"\cf2 \strokec2 \
\cf2 \strokec4 #\strokec5 include\strokec4  \strokec6 "geometry_msgs/Point.h"\cf2 \strokec2 \
\cf2 \strokec4 #\strokec5 include\strokec4  \strokec6 "geometry_msgs/Quaternion.h"\cf2 \strokec2 \
\cf2 \strokec4 #\strokec5 include\strokec4  \strokec6 <cmath>\cf2 \strokec2 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec7 double\cf2 \strokec2  \cf2 \strokec8 calculateDirection\cf2 \strokec2 (\cf2 \strokec7 double\cf2 \strokec2  x1, \cf2 \strokec7 double\cf2 \strokec2  y1, \cf2 \strokec7 double\cf2 \strokec2  x2, \cf2 \strokec7 double\cf2 \strokec2  y2) \{\
    \cf2 \strokec9 // Calcola l'angolo in radianti tra due punti (x1, y1) e (x2, y2)\cf2 \strokec2 \
    \cf2 \strokec5 return\cf2 \strokec2  \cf2 \strokec10 atan2\cf2 \strokec2 (y2 - y1, x2 - x1);\
\}\
\
\cf2 \strokec7 int\cf2 \strokec2  \cf2 \strokec8 main\cf2 \strokec2 (\cf2 \strokec7 int\cf2 \strokec2  argc, \cf2 \strokec7 char\cf2 \strokec2  **argv) \{\
    ros::\cf2 \strokec10 init\cf2 \strokec2 (argc, argv, \cf2 \strokec6 "gps_odom_publisher"\cf2 \strokec2 );\
    ros::NodeHandle nh;\
\
    ros::Publisher odom_pub = nh.\cf2 \strokec10 advertise\cf2 \strokec2 <nav_msgs::Odometry>(\cf2 \strokec6 "gps_odom"\cf2 \strokec2 , \cf2 \strokec7 10\cf2 \strokec2 );\
\
    ros::Rate \cf2 \strokec8 loop_rate\cf2 \strokec2 (\cf2 \strokec7 10\cf2 \strokec2 );  \cf2 \strokec9 // 10 Hz\cf2 \strokec2 \
\
    \cf2 \strokec7 double\cf2 \strokec2  prev_e = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
    \cf2 \strokec7 double\cf2 \strokec2  prev_n = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
\
    \cf2 \strokec5 while\cf2 \strokec2  (ros::\cf2 \strokec10 ok\cf2 \strokec2 ()) \{\
        \cf2 \strokec9 // Replace these values with your ENU coordinates\cf2 \strokec2 \
        \cf2 \strokec7 double\cf2 \strokec2  e = \cf2 \strokec7 10.0\cf2 \strokec2 ;\
        \cf2 \strokec7 double\cf2 \strokec2  n = \cf2 \strokec7 5.0\cf2 \strokec2 ;\
        \cf2 \strokec7 double\cf2 \strokec2  u = \cf2 \strokec7 0.0\cf2 \strokec2 ;  \cf2 \strokec9 // Assuming flat terrain\cf2 \strokec2 \
\
        \cf2 \strokec9 // Calculate direction (angle) between previous and current position\cf2 \strokec2 \
        \cf2 \strokec7 double\cf2 \strokec2  direction = \cf2 \strokec10 calculateDirection\cf2 \strokec2 (prev_e, prev_n, e, n);\
\
        nav_msgs::Odometry odom;\
        odom.header.stamp = ros::Time::\cf2 \strokec10 now\cf2 \strokec2 ();\
        odom.header.frame_id = \cf2 \strokec6 "odom"\cf2 \strokec2 ;\
        odom.child_frame_id = \cf2 \strokec6 "base_link"\cf2 \strokec2 ;\
\
        \cf2 \strokec9 // Position\cf2 \strokec2 \
        odom.pose.pose.position.x = e;\
        odom.pose.pose.position.y = n;\
        odom.pose.pose.position.z = u;\
\
        \cf2 \strokec9 // Orientation (quaternion)\cf2 \strokec2 \
        \cf2 \strokec7 double\cf2 \strokec2  theta = direction;  \cf2 \strokec9 // Angle in radians\cf2 \strokec2 \
        odom.pose.pose.orientation.x = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.pose.pose.orientation.y = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.pose.pose.orientation.z = \cf2 \strokec10 sin\cf2 \strokec2 (theta / \cf2 \strokec7 2\cf2 \strokec2 );\
        odom.pose.pose.orientation.w = \cf2 \strokec10 cos\cf2 \strokec2 (theta / \cf2 \strokec7 2\cf2 \strokec2 );\
\
        \cf2 \strokec9 // Twist (not necessary for your case, but included for completeness)\cf2 \strokec2 \
        odom.twist.twist.linear.x = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.linear.y = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.linear.z = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.angular.x = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.angular.y = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
        odom.twist.twist.angular.z = \cf2 \strokec7 0.0\cf2 \strokec2 ;\
\
        \cf2 \strokec9 // Publish the message\cf2 \strokec2 \
        odom_pub.\cf2 \strokec10 publish\cf2 \strokec2 (odom);\
\
        \cf2 \strokec9 // Update previous position\cf2 \strokec2 \
        prev_e = e;\
        prev_n = n;\
\
        ros::\cf2 \strokec10 spinOnce\cf2 \strokec2 ();\
        loop_rate.\cf2 \strokec10 sleep\cf2 \strokec2 ();\
    \}\
\
    \cf2 \strokec5 return\cf2 \strokec2  \cf2 \strokec7 0\cf2 \strokec2 ;\
\}}